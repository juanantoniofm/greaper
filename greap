#!/usr/bin/python


import argparse
import sys

from lib.parsmap import apache_log, field_map, consumer, convert_time, app_log
from lib.parsmap import mpt,list_fields,  broadcast, get_producer
from lib.helpers import output 
import myfilters 

command_parser = argparse.ArgumentParser(
        description="get some cool stats from apache logs")

command_parser.add_argument("-v","--verbose", action="store_true",
        help="enable debug output", required=False, default=False)

command_parser.add_argument("-q","--query", dest="query",
        help="select this fields from the log line.\n available:\n {0}".format(list_fields()),
        required=False)

command_parser.add_argument("-f","--filter", dest="filters",
        help="use custom built filters (available: {0})".format(
                ", ".join([ f for f in dir(myfilters) if not f.startswith("__") ])),
        required=False)

command_parser.add_argument("-i","--input", dest="input_file",
        help="Filename to read input from", required=True)

command_parser.add_argument("-k","--kind", dest="log_format",
        help="Define which kind of log to parse (available: {0})".format(
            ", ".join(mpt.iterkeys())),
        required=False)

command_parser.add_argument("-g","--grep", dest="grep_regex",
        help="Use the expresion t filter the input", required=False)

command_parser.add_argument("-ng","--ngrep",  action="store_false", default = True,
        help="negative grep. Filter the lines that NOT match the expresion (like grep -v regex)", required=False)

args = vars(command_parser.parse_args()) 



################################################################################

stats = {
        "200" : { "count" : 0},
        }

loglevel = "QUIET"  # the default value is DEBUG untill further development


def define_loglevel():
    """sets a level of detail for the log."""
    global loglevel
    if args["verbose"]:
        loglevel = "DEBUG"

def grepit(line, regex=None):
    """only returns a line if it matches the rexex"""
    if regex is None:
        return line
    else:
        if (regex in line) == args["ngrep"]:
            return line


def read_in_lines(fh = None):
    """read a file line by line
    In a lazy way
    """
    while True:
        line = fh.readline()
        if not line:
            break
        else:
            if not grepit(line, args["grep_regex"] ):
                # check that the line matches with the pre-regex and if not, break
                yield ""
            else:
                output(line, "DEBUG:",loglevel) # print debug info
                yield line
 
################################################################################

@consumer
def get_stats():
    global stats
    while True:
        r = (yield)
        add_entry(r, stats)
        output(stats, "DEBUG:", loglevel)


@consumer
def neilfilter():
    while True:
        r=(yield)
        # Check if the uri is on the interests list
        interesting = ["/integration-opera/services",
                      "/ws/fidelio"]
        if r['request'] in interesting:
            output(r, "DEBUG",loglevel)
            #print r["host"], r["request"]
            output("".join[ convert_time(r['datetime']),r["host"] , r["request"] ])

@consumer
def plain_print():
    while True:
        r=(yield)
        print r

def compose(query, data=None):
    """compose the resulting line of the query ready for output.
    :query: list of params to print from the log line parsed.
    :data:  the dictionary with the parsed line.
    :return: the line to print with the fields in the order specified in query."""
    rl = " "
    #- first figure out which fields to print. either all of just queried ones.
    if query is None:
        queried_fields = [x for x in data.iterkeys()]
        output(queried_fields.__str__(),"DEBUG",loglevel)
    else:
        queried_fields = query.split(",")
    #- then go and create the line
    for f in queried_fields:
        rl += data[f].__str__() + " "
    return rl




@consumer
def query_print():
    while True:
        r=(yield)
        output(compose(args["query"], r))


################################################################################

try:
    output(args.__str__(),"DEBUG",loglevel) # show the params for debug purposes
    define_loglevel()
    lines = read_in_lines(open(args["input_file"],"r"))

    log = get_producer(args["log_format"])(lines)

    broadcast(log, [query_print()])

except Exception as e:
    output(e.__str__(), "ERROR")
    sys.exit(1)

